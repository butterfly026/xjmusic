package io.outright.xj.core.external.amazon;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;
import java.io.UnsupportedEncodingException;
import java.net.URL;
import java.net.URLEncoder;
import java.security.MessageDigest;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.Iterator;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.SimpleTimeZone;
import java.util.SortedMap;
import java.util.TreeMap;

/**
 * Sample AWS4 signer demonstrating how to sign requests to Amazon S3 using an
 * 'Authorization' header.
 */
class AmazonSignerV4 {
  private static Logger log = LoggerFactory.getLogger(AmazonSignerV4.class);

  // configs
  private URL endpointUrl;
  private String httpMethod;
  private String serviceName;
  private String regionName;

  // constants
  private static final String SCHEME = "AWS4";
  private static final String ALGORITHM = "HMAC-SHA256";
  private static final String TERMINATOR = "aws4_request";

  // format strings for the date/time and date stamps required during signing
  private static final String ISO8601BasicFormat = "yyyyMMdd'T'HHmmss'Z'";
  private static final String DateStringFormat = "yyyyMMdd";

  // date/time formats
  private final SimpleDateFormat dateTimeFormat;
  private final SimpleDateFormat dateStampFormat;

  /**
   * Create a new AWS V4 signer.
   *
   * @param endpointUrl The service endpoint, including the path to any resource.
   * @param httpMethod  The HTTP verb for the request, e.g. GET.
   * @param serviceName The signing name of the service, e.g. 's3'.
   * @param regionName  The system name of the AWS region associated with the
   *                    endpoint, e.g. us-east-1.
   */
  AmazonSignerV4(URL endpointUrl, String httpMethod,
                 String serviceName, String regionName) {
    this.endpointUrl = endpointUrl;
    this.httpMethod = httpMethod;
    this.serviceName = serviceName;
    this.regionName = regionName;

    dateTimeFormat = new SimpleDateFormat(ISO8601BasicFormat);
    dateTimeFormat.setTimeZone(new SimpleTimeZone(0, "UTC"));
    dateStampFormat = new SimpleDateFormat(DateStringFormat);
    dateStampFormat.setTimeZone(new SimpleTimeZone(0, "UTC"));
  }

//    def sign
//              @expires = 10.hours.from_now.utc.iso8601
//              render json: {
//                acl: 'public-read',
//                 aws-access-key-id: ENV['AWS_ACCESS_KEY_ID'],
//                  bucket: 'sump',
//                  expires: @expires,
//                key: "uploads/#{params[:name]}",
//                  policy: policy,
//                  signature: signature,
//                  success_action_status: '201',
//                  'Content-Type' => params[:type],
//                'Cache-Control' => 'max-age=630720000, public'
//               }, status: :ok
//            end
//
//            def signature
//              Base64.strict_encode64(
//                OpenSSL::HMAC.digest(
//                  OpenSSL::Digest::Digest.new('sha1'),
//                  ENV['AWS_SECRET_ACCESS_KEY'],
//                  policy({ secret_access_key: ENV['AWS_SECRET_ACCESS_KEY'] })
//                )
//              )
//            end
//
//            def policy(options = {})
//              Base64.strict_encode64({
//                expiration: @expires,
//                conditions: [
//                  { bucket: 'INSERT-BUCKET-NAME-HERE' },
//                  { acl: 'public-read' },
//                  { expires: @expires },
//                  { success_action_status: '201' },
//                  [ 'starts-with', '$key', '' ],
//                  [ 'starts-with', '$Content-Type', '' ],
//                  [ 'starts-with', '$Cache-Control', '' ],
//                  [ 'content-length-range', 0, 524288000 ]
//                  ]
//                }.to_json
//              )
//            end
//          end
//        end

  /**
   * Computes an AWS4 signature for a request, ready for inclusion as an
   * 'Authorization' header.
   *
   * @param headers         The request headers; 'Host' and 'X-Amz-Date' will be added to
   *                        this set.
   * @param queryParameters Any query parameters that will be added to the endpoint. The
   *                        parameters should be specified in canonical format.
   * @param awsAccessKey    The user's AWS Access Key.
   * @param awsSecretKey    The user's AWS Secret Key.
   * @return The computed authorization string for the request. This value
   * needs to be set as the header 'Authorization' on the subsequent
   * HTTP request.
   */
  String computeSignature(Map<String, String> headers,
                          Map<String, String> queryParameters,
                          String awsAccessKey,
                          String awsSecretKey) {
    // first get the date and time for the subsequent request, and convert
    // to ISO 8601 format for use in signature generation
    Date now = new Date();
    String dateTimeStamp = dateTimeFormat.format(now);

    // update the headers with required 'x-amz-date' and 'host' values
    headers.put("x-amz-date", dateTimeStamp);

    String hostHeader = endpointUrl.getHost();
    int port = endpointUrl.getPort();
    if (port > -1) {
      hostHeader = hostHeader.concat(":" + Integer.toString(port));
    }
    headers.put("Host", hostHeader);

    // canonicalize the headers; we need the set of header names as well as the
    // names and values to go into the signature process
    String canonicalizedHeaderNames = getCanonicalizeHeaderNames(headers);
    String canonicalizedHeaders = getCanonicalizedHeaderString(headers);

    // if any query string parameters have been supplied, canonicalize them
    String canonicalizedQueryParameters = getCanonicalizedQueryString(queryParameters);

    // canonicalize the various components of the request
    String canonicalRequest = getCanonicalRequest(endpointUrl, httpMethod,
      canonicalizedQueryParameters, canonicalizedHeaderNames,
      canonicalizedHeaders);
    log.debug("Canonical Request: {}", canonicalRequest);

    // construct the string to be signed
    String dateStamp = dateStampFormat.format(now);
    String scope = dateStamp + "/" + regionName + "/" + serviceName + "/" + TERMINATOR;
    String stringToSign = getStringToSign(SCHEME, ALGORITHM, dateTimeStamp, scope, canonicalRequest);
    log.debug("String to Sign: {}", stringToSign);

    // compute the signing key
    byte[] kSecret = (SCHEME + awsSecretKey).getBytes();
    byte[] kDate = sign(dateStamp, kSecret);
    byte[] kRegion = sign(regionName, kDate);
    byte[] kService = sign(serviceName, kRegion);
    byte[] kSigning = sign(TERMINATOR, kService);
    byte[] signature = sign(stringToSign, kSigning);

    String credentialsAuthorizationHeader =
      "Credential=" + awsAccessKey + "/" + scope;
    String signedHeadersAuthorizationHeader =
      "SignedHeaders=" + canonicalizedHeaderNames;
    String signatureAuthorizationHeader =
      "Signature=" + toHex(signature);

    return SCHEME + "-" + ALGORITHM + " "
      + credentialsAuthorizationHeader + ", "
      + signedHeadersAuthorizationHeader + ", "
      + signatureAuthorizationHeader;
  }


  /**
   * Returns the canonical collection of header names that will be included in
   * the signature. For AWS4, all header names must be included in the process
   * in sorted canonicalized order.
   */
  private static String getCanonicalizeHeaderNames(Map<String, String> headers) {
    List<String> sortedHeaders = new ArrayList<>();
    sortedHeaders.addAll(headers.keySet());
    sortedHeaders.sort(String.CASE_INSENSITIVE_ORDER);

    StringBuilder buffer = new StringBuilder();
    for (String header : sortedHeaders) {
      if (buffer.length() > 0) buffer.append(";");
      buffer.append(header.toLowerCase());
    }

    return buffer.toString();
  }

  /**
   * Computes the canonical headers with values for the request. For AWS4, all
   * headers must be included in the signing process.
   */
  private static String getCanonicalizedHeaderString(Map<String, String> headers) {
    if (headers == null || headers.isEmpty()) {
      return "";
    }

    // step1: sort the headers by case-insensitive order
    List<String> sortedHeaders = new ArrayList<>();
    sortedHeaders.addAll(headers.keySet());
    sortedHeaders.sort(String.CASE_INSENSITIVE_ORDER);

    // step2: form the canonical header:value entries in sorted order.
    // Multiple white spaces in the values should be compressed to a single
    // space.
    StringBuilder buffer = new StringBuilder();
    for (String key : sortedHeaders) {
      buffer.append(key.toLowerCase().replaceAll("\\s+", " ")).append(":").append(headers.get(key).replaceAll("\\s+", " "));
      buffer.append("\n");
    }

    return buffer.toString();
  }

  /**
   * Canonical request string to go into the signer process; this
   * consists of several canonical sub-parts.
   *
   * @return canonical request string
   */
  private static String getCanonicalRequest(URL endpoint,
                                            String httpMethod,
                                            String queryParameters,
                                            String canonicalizedHeaderNames,
                                            String canonicalizedHeaders) {
    return httpMethod + "\n" +
      getCanonicalizedResourcePath(endpoint) + "\n" +
      queryParameters + "\n" +
      canonicalizedHeaders + "\n" +
      canonicalizedHeaderNames + "\n";
  }

  /**
   * Returns the canonicalized resource path for the service endpoint.
   */
  private static String getCanonicalizedResourcePath(URL endpoint) {
    if (endpoint == null) {
      return "/";
    }
    String path = endpoint.getPath();
    if (path == null || path.isEmpty()) {
      return "/";
    }

    String encodedPath = urlEncode(path, true);
    if (encodedPath.startsWith("/")) {
      return encodedPath;
    } else {
      return "/".concat(encodedPath);
    }
  }

  /**
   * Examines the specified query string parameters and returns a
   * canonicalized form.
   * <p>
   * The canonicalized query string is formed by first sorting all the query
   * string parameters, then URI encoding both the key and value and then
   * joining them, in order, separating key value pairs with an '&'.
   *
   * @param parameters The query string parameters to be canonicalized.
   * @return A canonicalized form for the specified query string parameters.
   */
  private static String getCanonicalizedQueryString(Map<String, String> parameters) {
    if (parameters == null || parameters.isEmpty()) {
      return "";
    }

    SortedMap<String, String> sorted = new TreeMap<>();

    Iterator<Map.Entry<String, String>> pairs = parameters.entrySet().iterator();
    while (pairs.hasNext()) {
      Map.Entry<String, String> pair = pairs.next();
      String key = pair.getKey();
      String value = pair.getValue();
      sorted.put(urlEncode(key, false), urlEncode(value, false));
    }

    StringBuilder builder = new StringBuilder();
    pairs = sorted.entrySet().iterator();
    while (pairs.hasNext()) {
      Map.Entry<String, String> pair = pairs.next();
      builder.append(pair.getKey());
      builder.append("=");
      builder.append(pair.getValue());
      if (pairs.hasNext()) {
        builder.append("&");
      }
    }

    return builder.toString();
  }

  /**
   * Get string to sign
   *
   * @return a string to sign
   */
  private static String getStringToSign(String scheme, String algorithm, String dateTime, String scope, String canonicalRequest) {
    return scheme + "-" + algorithm + "\n" +
      dateTime + "\n" +
      scope + "\n" +
      toHex(hash(canonicalRequest));
  }

  /**
   * Hashes the string contents (assumed to be UTF-8) using the SHA-256
   * algorithm.
   */
  private static byte[] hash(String text) {
    try {
      MessageDigest md = MessageDigest.getInstance("SHA-256");
      md.update(text.getBytes("UTF-8"));
      return md.digest();
    } catch (Exception e) {
      throw new RuntimeException("Unable to compute hash while signing request: " + e.getMessage(), e);
    }
  }

  /**
   * Sign a string
   *
   * @param stringData to sign
   * @param key        to sign with
   * @return signed key
   */
  private static byte[] sign(String stringData, byte[] key) {
    try {
      byte[] data = stringData.getBytes("UTF-8");
      Mac mac = Mac.getInstance(ALGORITHM);
      mac.init(new SecretKeySpec(key, ALGORITHM));
      return mac.doFinal(data);
    } catch (Exception e) {
      throw new RuntimeException("Unable to calculate a request signature: " + e.getMessage(), e);
    }
  }

  /**
   * Encode a URL string
   *
   * @param url           to encode
   * @param keepPathSlash optional
   * @return encoded url string
   */
  private static String urlEncode(String url, boolean keepPathSlash) {
    String encoded;
    try {
      encoded = URLEncoder.encode(url, "UTF-8");
    } catch (UnsupportedEncodingException e) {
      throw new RuntimeException("UTF-8 encoding is not supported.", e);
    }
    if (keepPathSlash) {
      encoded = encoded.replace("%2F", "/");
    }
    return encoded;
  }

  /**
   * Converts byte data to a Hex-encoded string.
   *
   * @param data data to hex encode.
   * @return hex-encoded string.
   */
  private static String toHex(byte[] data) {
    StringBuilder sb = new StringBuilder(data.length * 2);
    for (byte aData : data) {
      String hex = Integer.toHexString(aData);
      if (hex.length() == 1) {
        // Append leading zero.
        sb.append("0");
      } else if (hex.length() == 8) {
        // Remove ff prefix from negative numbers.
        hex = hex.substring(6);
      }
      sb.append(hex);
    }
    return sb.toString().toLowerCase(Locale.getDefault());
  }

}
